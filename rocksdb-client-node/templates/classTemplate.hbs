interface RocksDBResponse {
    success: boolean;
    result?: string;
    error?: string;
}

class RocksDBClient {
    host: string;
    port: number;
    token: string | null;
    socket: any;
    timeout: number;
    retryInterval: number;
    private pool: any[];

    /**
     * Constructor to initialize the RocksDB client.
     *
     * @param {string} host The host of the RocksDB server.
     * @param {number} port The port of the RocksDB server.
     * @param {string|null} [token] Optional authentication token for the RocksDB server.
     * @param {number} [timeout=20] Timeout in seconds.
     * @param {number} [retryInterval=2] Retry interval in seconds.
     */
    constructor(host: string, port: number, token: string | null = null, timeout: number = 20, retryInterval: number = 2) {
        this.host = host;
        this.port = port;
        this.token = token;
        this.timeout = timeout;
        this.retryInterval = retryInterval;
        this.socket = null;

        this.pool = [];
    }

    /**
     * Closes all connections in the pool.
     */
    close(): void {
        for (const socket of this.pool) {
            socket.end();
        }
        this.pool = [];
    }

    private async createSocket(host: string, port: number): Promise<any> {
        return new Promise((resolve, reject) => {
            const socket = createConnection({ host, port }, () => {
                socket.setMaxListeners(3000);
                resolve(socket);
            });
            socket.on('error', reject);
        });
    }

    private async getConnection(): Promise<any> {
        if (this.pool.length > 0) {
            return this.pool.pop();
        }
        return this.createSocket(this.host, this.port);
    }

    private releaseConnection(socket: any) {
        this.pool.push(socket);
    }

    async sendRequest(request: object): Promise<RocksDBResponse> {
        if (this.token !== null) {
            (request as any).token = this.token;
        }

        const requestJson = JSON.stringify(request) + "\n";
        const socket = await this.getConnection();
        socket.write(requestJson);

        return new Promise((resolve, reject) => {
            socket.once('data', (responseJson: string) => {
                this.releaseConnection(socket);

                try {
                    const response: RocksDBResponse = JSON.parse(responseJson);
                    resolve(response);
                } catch (error) {
                    reject(new Error("Invalid response from server"));
                }
            });

            socket.once('error', (err: Error) => {
                this.releaseConnection(socket);
                reject(err);
            });
        });
    }

    /**
     * Handles the response from the server.
     *
     * @param {object} response The response from the server.
     * @return {any} The result from the response.
     * @throws {Error} If the response indicates an error.
     */
    handleResponse(response: RocksDBResponse): string|null {
        if (response.success && response.result !== undefined) {
            return response.result;
        }

        throw new Error(response.error);
    }

{{{methods}}}
}

// Export the class
export default RocksDBClient;