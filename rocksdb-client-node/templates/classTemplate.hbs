interface RocksDBResponse {
    success: boolean;
    result?: string;
    error?: string;
}

class RocksDBClient {
    host: string;
    port: number;
    token: string | null;
    socket: any;
    timeout: number;
    retryInterval: number;

    /**
     * Constructor to initialize the RocksDB client.
     *
     * @param {string} host The host of the RocksDB server.
     * @param {number} port The port of the RocksDB server.
     * @param {string|null} [token] Optional authentication token for the RocksDB server.
     * @param {number} [timeout=20] Timeout in seconds.
     * @param {number} [retryInterval=2] Retry interval in seconds.
     */
    constructor(host: string, port: number, token: string | null = null, timeout: number = 20, retryInterval: number = 2) {
        this.host = host;
        this.port = port;
        this.token = token;
        this.timeout = timeout;
        this.retryInterval = retryInterval;
        this.socket = null;
    }

    /**
     * Connects to the RocksDB server with retry mechanism.
     *
     * @throws {Error} If unable to connect to the server.
     */
    async connect(): Promise<void> {
        const startTime = Date.now();

        while (true) {
            try {
                this.socket = await this.createSocket(this.host, this.port);
                return; // Connection successful
            } catch (error: any) {
                if ((Date.now() - startTime) >= this.timeout * 1000) {
                    throw new Error(`Unable to connect to server: ${error.message}`);
                }
                await this.sleep(this.retryInterval * 1000);
            }
        }
    }
    
    /**
     * Closes the socket connection.
     */
    close(): void {
        if (this.socket) {
            this.socket.end();
            this.socket = null;
        }
    }

    /**
     * Creates a socket connection.
     * @private
     */
    createSocket(host: string, port: number): Promise<any> {
        return new Promise((resolve, reject) => {
            const socket = require('net').createConnection({ host, port }, () => {
                resolve(socket);
            });
            socket.on('error', reject);
        });
    }

    /**
     * Sleeps for the given number of milliseconds.
     * @private
     */
    sleep(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Sends a request to the RocksDB server.
     *
     * @param {object} request The request to be sent.
     * @return {Promise<object>} The response from the server.
     * @throws {Error} If the response from the server is invalid.
     */
    async sendRequest(request: object): Promise<RocksDBResponse> {
        if (!this.socket) {
            await this.connect();
        }

        if (this.token !== null) {
            (request as any).token = this.token; // Add token to request if present
        }

        const requestJson = JSON.stringify(request) + "\n";
        this.socket.write(requestJson);

        const responseJson = await this.readSocket();
        const response = JSON.parse(responseJson);

        if (response === null) {
            throw new Error("Invalid response from server");
        }

        return response;
    }

    /**
     * Reads data from the socket.
     * @private
     */
    readSocket(): Promise<string> {
        return new Promise((resolve, reject) => {
            let data = '';
            this.socket.on('data', (chunk: string) => {
                data += chunk;
                if (data.includes("\n")) {
                    resolve(data);
                }
            });
            this.socket.on('error', reject);
        });
    }

    /**
     * Handles the response from the server.
     *
     * @param {object} response The response from the server.
     * @return {any} The result from the response.
     * @throws {Error} If the response indicates an error.
     */
    handleResponse(response: RocksDBResponse): string|null {
        if (response.success && response.result !== undefined) {
            return response.result;
        }

        throw new Error(response.error);
    }

{{{methods}}}
}

// Export the class
export default RocksDBClient;